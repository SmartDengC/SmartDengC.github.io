import{_ as s,o as i,c as a,e as n}from"./app-BhrpVKwE.js";const e={},l=n(`<p>作为后端开发者，了解 linux 的一些简单操作还是很有必要的，因为不是所有的地方都会有服务器运维的人员的，这个时候就需要自己来了。 今天就简单的聊一下，当磁盘爆满时，我们如果找到占用空间大的文件。</p><p>其实很多时候，你需要了解的当前系统下存在哪些大文件，如果超多 1G 或者 100M 的文件；那么如何把这些大文件搜索出来呢？ <code>find . -type f -size +800M</code> 但是上面的命令，我们只能看到超过 800M 大小的文件名称，但是对文件的详细信息一无所知。 <code>find . -type f -size +800M -print0 | xargs -0 ls -l</code> 当我们只需要找到超过 800M 的文件，并显示查找出来的文件的具体大小的时候，可以用下面命令： <code>find . -type f -size +800M -print0 | xargs -0 du -h</code> 如果我们需要对查找的结果按照文件的大小排序，那么可以使用下面命令 <code>find . -type f -size +800M -print0 | xargs -0 du -h | sort -nr</code></p><h2 id="如何查找-linux-下的大目录" tabindex="-1"><a class="header-anchor" href="#如何查找-linux-下的大目录"><span>如何查找 Linux 下的大目录</span></a></h2><p>有的时候我们需要看下那个目录占用的总空间大， 我们用 ls -alh 只能看到当前一层的大小，我们可以用 du 来实现， 这里有一个--max-depth 的参数，就是只输出一层记录。 <code>du -h --max-depth=1</code> 如果想要排序可以加上 sort -n 的参数。</p><h2 id="扩展知识说明" tabindex="-1"><a class="header-anchor" href="#扩展知识说明"><span>扩展知识说明</span></a></h2><h3 id="find-扩展说明" tabindex="-1"><a class="header-anchor" href="#find-扩展说明"><span>find 扩展说明</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 在某个路径下查找文件。在/etc下查找&#39;*.log&#39;的文件</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">find</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /etc -name </span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">*.log</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 扩展：列出某个路径下所有的文件，包括子目录</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">find</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /etc -name </span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">*</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># find 使用正则表达式</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">find</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> ./ -name </span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">[a-z][0-9].log</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">find</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> ./ -type d</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">f</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">find</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> ./ -size +800M</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="find-print0-和-xargs-0-原理及用法" tabindex="-1"><a class="header-anchor" href="#find-print0-和-xargs-0-原理及用法"><span>find -print0 和 xargs -0 原理及用法</span></a></h3><p>find -print0 表示在 find 的每一个结果之后加一个 NULL 字符，而不是默认加一个换行符。find 默认在每一个结果后面加一个&#39;\\n&#39;, 所以输出结果是一行一行的，当使用-print0 之后， 就变成一行了。</p><p>然后 xargs -0 表示 xargs 用 NULL 来作为分隔符。这样前后搭配就不会出现空格和换行符的错误。选择 null 作为分隔符，是因为一般编程语言把 NULL 作为字符串结束的标志，所以文件不可能以 NULL 结尾，这样确保万无一失。</p><p>比如下面这种情况的话，就很好的说明问题。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">find</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> ./ -name </span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">*.log</span><span style="--shiki-light:#B5695999;--shiki-dark:#C98A7D99;">&#39;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> |</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> xargs</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> rm</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>像是这样子的话，如果文件里面有空格，比如说<code>file a.log</code> 这样 xargs 就会把文件名分开，分别是 file 和 a.txt，这样子就会出问题。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>rm: .//file: No such file or directory</span></span>
<span class="line"><span>rm: b.log: No such file or directory</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,14),d=[l];function h(t,p){return i(),a("div",null,d)}const k=s(e,[["render",h],["__file","index.html.vue"]]);export{k as default};
